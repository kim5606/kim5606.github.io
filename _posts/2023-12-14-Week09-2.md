---
title: 정글 9주차
author: cotes
date: 2023-12-14 14:30:00 +0800
categories: [크래프톤 정글]
tags: [PintOS]
pin: true
math: true
mermaid: true
---

# 2023.12.14 TIL

## KeyWord 정리

---

### Virtual Memory

메모리 관리 기법 중 하나로 컴퓨터 시스템에 실제로 이용 가능한 기억 자원을 이상적으로 추상화하여 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 말한다.

> > 각 프로그램에 실제 메모리 주소가 아닌 가상 메모리 주소를 주는 방식

![Alt text](https://raw.githubusercontent.com/kim5606/kim5606.github.io/main/_posts/image-5.png)

가상 주소 공간은 메모리 관리 장치 (MMU)에 의해 물리 주소로 변환된다.

1. 세그먼트 방식

가상 메모리를 크기가 아닌 논리적 단위로 분할하여 메모리에 적재하는 방식이다.

논리적 단위란, `코드`,`데이터`,`스택` 과 같은 단위를 말하며 때문에 모든 단위 조각의 크기가 같지 않다.

장점 - 내부 단편화 문제가 해소된다.
보호와 공유 기능을 수행 가능하다.
프로그램의 중요 부분과 아닌 부분을 분리하여 저장할 수 있고 같은 부분은 한 번에 저장 가능하다.

단점 - 외부 단편화의 문제가 발생할 수 있다.

2. 페이징 방식

가상 메모리를 크기 단위로 분할하여 메모리에 적재하는 방식이다.
페이징을 만들어, 가상 메모리와 물리 메모리를 매핑시켜 확인한다.

장점 - 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요 없고,
물리 메모리의 남는 메모리에 적절히 배치되기에 외부 단편화가 발생하지 않는다.

단점 - 내부 단편화 문제가 발생할 수 있다. 내부 단편화 해결을 위해 페이지를 작게하면 오히려 복잡해져 효율성이 떨어진다.

---

### Page Table

페이징 테이블은 페이지와
물리적 프레임 간의 매핑 정보를 저장하는 자료 구조

하나의 프로세스는 하나의 페이지 테이블을 가짐.

각 페이지는 `페이지 번호` , `오프셋` 으로 구성되며, `페이지 번호`를 `프레임 번호`로 매핑 시켜 `논리적 주소`를 `물리적 주소`로 변환한다.

![Alt text](https://raw.githubusercontent.com/kim5606/kim5606.github.io/main/_posts/image-6.png)

### Translation Lookaside Buffer (TLB)

페이징의 단점 중 하나는 매번 메모리에 상주하는 페이지 테이블을 읽어야 한다는 것이며, 이로 인해 엄청난 오버헤드가 발생한다. 주소 변환 속도를 향상시키기 위해 TLB(Top-Level Buffer)라고도 불리는 이 하드웨어 캐시를 사용할 수 있다.

TLB는 메모리 관리 장치(MMU)의 일부로, 자주 참조되는 가상 주소와 물리 주소 간의 변환 정보를 저장하는 하드웨어 캐시다. 따라서 `캐시`라는 용어가 더 적합하며, 이를 통해 가상 주소에서 물리 주소로의 변환 속도를 높일 수 있다.

TLB에 정보가 있으면 TLB 히트, 없으면 TLB 미스가 발생한다.

일반적인 TLB는 32, 64, 128개의 엔트리를 가지며, 각 엔트리는 가상 페이지 번호(VPN), 물리 페이지 번호(PFN), 그리고 기타 필요한 제어 비트 등을 저장한다. 이를 통해 가상 주소를 빠르게 물리 주소로 변환할 수 있다.

### Page Fault

페이지 폴트는 컴퓨팅에서 발생하는 예외 상황으로, 프로세스가 메모리 페이지에 적절한 준비 없이 접근할 때 메모리 관리 장치(MMU)가 발생시키는 것이다. 페이지에 접근하기 위해서는 해당 페이지가 프로세스의 가상 주소 공간에 매핑되어 있어야 하며, 실제 페이지 내용은 디스크와 같은 백업 저장소에서 로드되어야 할 수 있다. 페이지 폴트는 MMU에서 감지되지만 운영체제의 커널이 해당 페이지를 물리 메모리에서 사용 가능하게 만들거나 불법적인 메모리 접근을 거부하는 예외를 처리한다.

#### 마이너 페이지 폴트(Minor Page Fault):

페이지가 메모리에 로드되어 있지만 메모리 관리 장치에 로드되었다고 표시되지 않은 경우로, 소프트 페이지 폴트라고도 한다.

페이지 폴트 핸들러는 해당 페이지의 메모리 관리 장치 엔트리를 메모리에 있는 페이지를 가리키도록 만들고, 페이지가 메모리에 로드되었음을 나타내도록 표시하면 된다.

메모리를 다른 프로그램과 공유하며 해당 페이지가 이미 다른 프로그램을 위해 메모리에 로드된 경우에 발생할 수 있다.

#### 메이저 페이지 폴트(Major Page Fault):

프로그램 메모리 양을 필요에 따라 증가시키기 위한 운영 체제의 메커니즘

페이지 폴트가 발생할 때 디스크에서 프로그램 일부를 로드하기를 연기하며, 프로그램이 해당 부분을 사용하려고 시도할 때 페이지 폴트가 발생한다.

페이지가 폴트가 발생할 때 메모리에 로드되어 있지 않으면 메이저 또는 하드 페이지 폴트라고 한다.

메이저 페이지 폴트 핸들러는 메모리에서 빈 위치를 찾거나 다른 프로세스에 의해 사용 중인 페이지를 사용 가능하게 만들어야 한다.

이후, OS는 새 페이지의 데이터를 메모리로 읽고 메모리 관리 장치에 위치에 대한 엔트리를 추가하고 페이지가 로드된 것으로 표시한다.

#### 무효 페이지 폴트(Invalid Page Fault):

가상 주소 공간의 일부가 아닌 주소에 대한 참조로 페이지 폴트가 발생하면 무효 페이지 폴트라고 한다.

이 경우, 운영 체제의 페이지 폴트 핸들러는 해당 프로세스에 세그멘테이션 폴트를 전달하여 액세스가 무효임을 나타낸다.

일반적으로는 해당 참조가 유효하지 않다는 것을 나타내기 위해 프로세스에게 세그멘테이션 폴트가 전달되며, 코드 실행이 비정상적으로 종료될 수 있다.

세그멘테이션 폴트로도 알려져있다.

#### 성능 영향:

페이지 폴트는 시스템 성능을 저하시키고 스래싱을 유발할 수 있다.

하드 디스크 드라이브를 사용하는 전통적인 컴퓨터에서 메이저 페이지 폴트는 성능에 상당한 영향을 미칠 수 있다. 페이지 폴트로 인해 디스크 액세스 시간이 추가되므로, 전체 작업 시간이 약 8 ms 정도로 느려질 수 있다.

프로그램이 메모리에 대한 액세스 시간이 0.2 μs인 경우 페이지 폴트로 인해 작업이 약 40,000배 느려질 수 있다.

프로그램 또는 운영 체제의 성능 최적화는 주로 페이지 폴트의 수를 줄이는 데 중점을 두며, 이를 위해 적절한 페이지 교체 알고리즘을 구현하고 메모리 사용량을 최소화하며 메모리 지역성을 향상시킨다.

### Lazy Loading

비동기 로딩은 가상 메모리 뿐만 아니라 범용적으로 많이 사용되는 전략이다.

HTML에서 객체의 초기화를 해당 객체가 필요한 지점까지 미루는 기법으로서 사용된다.

다만 Virtual Memory에서의 Lazy Loding은 다른데

`실제 메모리 필요 시점에만 데이터를 로딩` 하는 전략이다.

디스크나 영구 저장소 같은 코스트가 큰 자원의 물리적 한계를 극복하기 위한 방법이다.

Busy Waiting과의 반대 개념으로서 진행된다.

1. 가상 주소 공간 할당

2. 페이지 부재 발생 (필연적이다.)

3. 페이지 로딩

4. 페이지 교체

> > 웹 페이지에 이동했을 때 비로소 로딩이 시작

... 슈뢰딩거의 고양이?

### Page Replacement Policy

- 가장 좋은 페이지 재할당 정책은, 페이지 폴트가 적게 나는 정책이다.

1. OPT (이론적 최적 페이지 교체)

- 페이지 교체 시, 미래에 사용될 페이지를 가장 늦게 사용될 것으로 선택한다.

- 일반적으로는 구현 불가능하지만, 메모리 참조 패턴을 정적으로 분석 가능한 경우나 런타임 분석이 가능한 특정 응용 프로그램 클래스의 경우에 근시적 사용 가능

2. NRU (최근 사용되지 않은 페이지 교체)

- 최근 사용된 페이지를 유지하는 것을 선호

3. FIFO (선입 선출)

- 가장 간단한 구현으로, 메모리 내의 모든 페이지를 Queue로 추적한다.

- 실제 사용에서는 성능이 좋지 않다.

- 벨라디의 변칙이 발생할 가능성이 높다.
  - 페이지 프레임 수를 늘리면 프레임이 늘어난다.
  - 즉, 페이지 폴트 확률이 늘어난다.

4. Second-Chance (세컨드 찬스 페이지 교체)

- 타이머 인터럽트나 다른 방법을 통해 일정 주기마다 페이지들의 `참조 비트`를 확인하고, 참조 되었으면(1) 참조 비트를 0으로 만든 뒤, `세컨드 찬스`를 부여한다.

- 즉, 페이지는 `참조 비트` (0,1)과 `세컨드 찬스`를 가진다.

5. Clock (클락 페이지 교체)

6. LRU (최근 사용된 페이지 교체)

7. Random (랜덤 페이지 교체)

8. NFU (자주 사용되지 않는 페이지 교체)

9. Aging (에이징 페이지 교체)

10. LDF (최장거리 우선)

### Anonymous page

디스크 상의 파일이나 데이터에 직접 매핑되지 않는 메모리 페이지

주로 Heap, stack 영역과 관련 있으며

일반적으로 동적으로 할당되었다가 사라지는 페이지가 Anonymous page이다.

> > 동적으로 할당되었다가 프로세스의 실행이 끝나면 해제되는 페이지는 주로 익명 페이지

### Swap Disk

주 메모리(RAM)가 모자라는 경우, 운영 체제가 일부 데이터를 주 메모리에서 디스크로 옮겨 저장하는데 사용된다.

해당 과정을 스왑 아웃, 혹은 페이지 아웃이라고 한다.

주 메모리와 디스크 사이의 데이터 교환 과정을 'Swap'이라고 한다.

Swap Disk는 주로 하드 디스크나 SSD 같은 영구 저장장치를 의미하며 대부분은 OS가 자동으로 처리한다.

> > RAM 부족할 때, 하드 디스크가 땜빵

### File-backed Page

File-backed page는 주로 메모리 관리 시스템에서 사용되는 용어로, 가상 메모리에 대응하는 물리적인 페이지(frame)가 파일과 연결되어 있는 페이지를 나타낸다.

일반적으로 가상 메모리는 물리적인 RAM의 확장을 위해 사용되고, 파일 시스템은 데이터를 저장하고 관리하기 위한 용도로 사용된다.

파일-backed page는 이 둘을 연결하여 특정 파일의 일부를 메모리에 로드하거나 파일에 저장된 데이터를 메모리에서 읽어오는 등의 동작을 지원한다.

프로그램이 실행될 때, 해당 프로그램의 실행 파일이나 필요한 데이터 파일의 일부가 가상 메모리에 매핑된다. 이렇게 메모리에 로드된 파일의 내용은 프로세스가 읽거나 쓸 수 있다. 변경된 내용은 메모리에만 존재하며, 파일에는 반영되지 않을 수 있다. 이러한 변경 사항이 파일에 영구적으로 저장되려면 명시적으로 파일에 쓰는(write) 작업을 수행해야 한다.

> > 익명 페이지와 반대 개념
