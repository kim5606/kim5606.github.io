---
title: 정글 7주차, Priority Inversion Problem
author: cotes
date: 2023-11-28 14:30:00 +0800
categories: [크래프톤 정글]
tags: [PintOS]
pin: true
math: true
mermaid: true
---

# 2023.11.28 TIL

## Priority Inversion Problem 요약

#### 개요

### 과제 목표

- Priority donation 구현
- Multiple donation 구현
- Nested donation 구현

### 수정해야 할 주요 파일

- `thread.*`
- `synch.*`

### Priority inversion Problem

- 우선순위가 높은 쓰레드가 우선순이 낮은 쓰레드를 기다리는 현상

![Alt text](https://raw.githubusercontent.com/kim5606/kim5606.github.io/main/_posts/5_lock.png)

- 해결 방법 - Priority donation

![Alt text](https://raw.githubusercontent.com/kim5606/kim5606.github.io/main/_posts/6_lock1.png)

### Multiple donation

- 스레드가 두 개 이상의 lock 보유 시, 각 lock에 의해 도네이션이 발생가
  능 -> 이전 상태의 우선순위를 기억하고 있어야 함

```mermaid
sequenceDiagram
    participant L as 스레드 L (priority: 31)
    participant M as 스레드 M (priority: 32)
    participant H as 스레드 H (priority: 33)
    participant A as Lock A
    participant B as Lock B

    L->>A: 점유 Lock A
    L->>B: 점유 Lock B
    M->>A: 요청 Lock A
    A->>L: 우선순위 도네이션 (priority: 32)
    H->>B: 요청 Lock B
    B->>L: 우선순위 도네이션 (priority: 33)
    L-->>B: 해지 Lock B
    Note over L: 우선순위 초기화 (priority: 31)
    Note over L: 이전 상태 기억 (priority: 32)
    L->>A: 유지 Lock A
    Note over L: 우선순위 변경 (priority: 32)
```

### 수정 및 추가 함수

- `void lock_acquire (struct lock *lock)`: lock을 점유하고 있는 스레드와 요청 하는 스레드의 우선순위를 비교하여 priority donation을 수행하도록 수정
- `void lock_release (struct lock *lock)`: donation list 에서 스레드를 제거하고 우선순위를 다시 계산하도록 remove_with_lock(), refresh_prioriy() 함수를 호출
- `void thread_set_priority (int new_priority)`: 스레드 우선순위 변경시 donation의 발생을 확인 하고 우선순위 변경을 위해 donation_priority()함수 추가
- `void donate_priority(void)` : priority donation을 수행
- `void remove_with_lock(struct lock *lock)` : donation list에서 스레드 엔트리를 제거
- `void refresh_priority(void)` : 우선순위를 다시 계산

-`struct thread`
