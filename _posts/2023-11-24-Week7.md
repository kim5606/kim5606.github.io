---
title: 정글 7주차 TIL(2)
author: cotes
date: 2023-11-24 23:00:00 +0800
categories: [크래프톤 정글]
tags: [PintOS]
pin: true
math: true
mermaid: true
---

# 2023.11.24 TIL

## 스레드

#### 스레드의 특징

- 활동적 엔터티
- 스레드는 다른 스레드와 동시 작동이 가능하다.
- 조정이 요구된다.
  - i/o 장치, CPU, 메모리를 공유한다

#### 프로세스와 스레드 차이

```bash
[code][data][files]       [code]        [data]        [files]
-------------------[pcb]  --------------------------------------
    [  regs  ]            [  regs  ]   [  regs  ]   [  regs  ]
    [  stack ]            [  stack ]   [  stack ]   [  stack ]
        | (Thread)            |            |             |
```

- 프로세스의 단일 스레드는 주소 공간으로 표시된다.
- 멀티 스레드 경우 더 복잡한 프로세스 제어 블록(pcb) 구조를 요구한다.
  - 스레드간 공유되는 정보, 스레드별 별도 컨텍스트 포함

#### 왜 스레드가 유용한가?

- 왜 스레드가 유용한가요?

  - 많은 업무를 한 시점에서 정확히 같이 시작할 수 있음 (병렬화)
  - 각각의 스레드에 대해 다양한 업무를 정확히 지시할 수 있음 (전문화)

- 병렬화 (parallelization)
  - 멀티코어 프로세서에서 스레드를 사용 시, 여러 작업을 동시에 수행하여 속도 향상이 된다.
- 전문화 (specialization)

  - 특정 스레드가 특정 데이터 또는 리소스에 접근하면 캐시 활용이 증가하여 전반적인 성능이 빨라진다. (hot cash)

- '다중 프로세스 애플리케이션'이 좋지 않나요?
  - 프로세스는 할당해야하는 주소 공간을 공유하지 않기 때문에 주소 공간 할당이 많이 필요하다.
  - 다중 스레드 구현에서는 스레드가 주소 공간을 공유하므로 컨텍스트 공간만 할당하면 된다.
  - 멀티 프로세스 이용 시, 메모리 요구 사항이 높아지고 (주소 공간 공유 x)
    비용이 더 많이 든다.(프로세스 간 통신 메커니즘)

#### 멀티 스레드는 단일 cpu일 때도 좋아?

- 컨텍스트 전환 비용이 짧게 구성된다.
- 응답성이 향상된다.
- 자원 관리 및 스케쥴링이 유연해진다.

#### 운영체제에서의 멀티스레딩의 이점

- 운영 체제의 커널을 멀티 스레딩
  - 운영 체제가 여러 실행 컨텍스트를 지원할 수 있도록 허용한다.
  - 일부 운영 체제 수준 서비스를 실행할 수 있다

#### 프로세스 vs 스레드

p = process / t = tread / b = both

- 주소 공간을 공유하는가 ? (t)
- 컨텍스트 전환에 시간이 더 걸리는것은 ? (p)
- 실행 컨텍스트를 갖는것은 ? (b)
- 다양하게 존재할 떄 캐시 온도가 더 높아지는 것은 ? (t) - thread의 전문성
- 몇가지 의사 소통 및 매커니즘을 활용하는 것은? (b)

#### 스레드를 지원하기 위해 필요한 것은?

- 스레드 데이터 구조
  - 스레드 식별, 자원 사용량 추정
- 스레드 생성 및 관리 매커니즘
- 스레드가 다음 작업을 수행하는 매커니즘
  - 동시에 서로 입력이나 결과 덮어쓰지 않도록 하기
  - 하나의 스레드가 결과를 기다릴 수 있도록 하기

#### 동시성 제어(Concurrency Control) vs 조정 (Coordination )

- 상호 배제 (mutual Exclusion)
  - 버스 줄 기다리는 것 처럼, 한번에 하나의 스레드만 허용되는 매커니즘
  - mutex 사용
  - 여러 프로세스나 스레드가 공유자원(데이터, 파일...)에 동시 사용하지 못하도록 막는 원칙

### 스레드 & 스레드 제작 예시

- 스레드 타입
  - 스레드 ID, PC, SP, 레지스터, 스택, 속성
  - 스레드 생성에 대해 FORK 제안 (proc, args)

```c
Thread thread1;
Shared_list list;
thread1 = fork(safe_insert,4);
safe_insert(6);
join(thread1); // Optional (메인 스레드 실행을 대기)
```

- 해당 결과는 4->6->nil / 6->4->nil 둘 다 가능하다.

#### 멀티 스레드 환경에서 포인터 주의점

```c
create new list element e
set e.value = X
read list and list.p_next
set e.pointer = list p_next
set list.p_next = e
```

- 동시성 문제의 시나리오를 계획해보자

1. 스레드 A와 B가 동시에 코드를 실행한다.
2. A가 'list.p_next'를 읽음 -> 'e'의 pointer를 이 값으로 설정
3. B가 거의 동시에 읽음 -> 또 다른 'e'의 pointer를 이 값으로 설정
4. 스레드 A가 'list.p_next'를 변경 -> 스레드 A가 'list.p_next'를 자신 새 요소 'e'로 설정한다.
5. 스레드 B가 'list.p_next'를 변경 -> 스레드 A가 'list.p_next'를 자신 새 요소 'e'로 설정한다.

#### mutex

위의 동시성 문제의 시나리오 떄문에 mutex 가 계획됐고 사용된다.

```c
mutex.lock(); // 동기화 시작
create new list element e
set e.value = X
read list and list.p_next
set e.pointer = list p_next
set list.p_next = e
mutex.unlock(); // 동기화 끝

```
