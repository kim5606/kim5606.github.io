---
title: 정글 7주차 핀토스 공부
author: cotes
date: 2023-11-28 15:00:00 +0800
categories: [크래프톤 정글]
tags: [PintOS]
pin: true
math: true
mermaid: true
---

# 2023.11.24 TIL

## 스레드

#### 스레드의 특징

- 활동적 엔터티
- 스레드는 다른 스레드와 동시 작동이 가능하다.
- 조정이 요구된다.
  - i/o 장치, CPU, 메모리를 공유한다

#### 프로세스와 스레드 차이

```bash
[code][data][files]       [code]        [data]        [files]
-------------------[pcb]  --------------------------------------
    [  regs  ]            [  regs  ]   [  regs  ]   [  regs  ]
    [  stack ]            [  stack ]   [  stack ]   [  stack ]
        | (Thread)            |            |             |
```

- 프로세스의 단일 스레드는 주소 공간으로 표시된다.
- 멀티 스레드 경우 더 복잡한 프로세스 제어 블록(pcb) 구조를 요구한다.
  - 스레드간 공유되는 정보, 스레드별 별도 컨텍스트 포함

#### 왜 스레드가 유용한가?

- 왜 스레드가 유용한가요?

  - 많은 업무를 한 시점에서 정확히 같이 시작할 수 있음 (병렬화)
  - 각각의 스레드에 대해 다양한 업무를 정확히 지시할 수 있음 (전문화)

- 병렬화 (parallelization)
  - 멀티코어 프로세서에서 스레드를 사용 시, 여러 작업을 동시에 수행하여 속도 향상이 된다.
- 전문화 (specialization)

  - 특정 스레드가 특정 데이터 또는 리소스에 접근하면 캐시 활용이 증가하여 전반적인 성능이 빨라진다. (hot cash)

- '다중 프로세스 애플리케이션'이 좋지 않나요?
  - 프로세스는 할당해야하는 주소 공간을 공유하지 않기 때문에 주소 공간 할당이 많이 필요하다.
  - 다중 스레드 구현에서는 스레드가 주소 공간을 공유하므로 컨텍스트 공간만 할당하면 된다.
  - 멀티 프로세스 이용 시, 메모리 요구 사항이 높아지고 (주소 공간 공유 x)
    비용이 더 많이 든다.(프로세스 간 통신 메커니즘)

#### 멀티 스레드는 단일 cpu일 때도 좋아?

- 컨텍스트 전환 비용이 짧게 구성된다.
- 응답성이 향상된다.
- 자원 관리 및 스케쥴링이 유연해진다.

#### 운영체제에서의 멀티스레딩의 이점

- 운영 체제의 커널을 멀티 스레딩
  - 운영 체제가 여러 실행 컨텍스트를 지원할 수 있도록 허용한다.
  - 일부 운영 체제 수준 서비스를 실행할 수 있다

#### 프로세스 vs 스레드

p = process / t = tread / b = both

- 주소 공간을 공유하는가 ? (t)
- 컨텍스트 전환에 시간이 더 걸리는것은 ? (p)
- 실행 컨텍스트를 갖는것은 ? (b)
- 다양하게 존재할 떄 캐시 온도가 더 높아지는 것은 ? (t) - thread의 전문성
- 몇가지 의사 소통 및 매커니즘을 활용하는 것은? (b)

#### 스레드를 지원하기 위해 필요한 것은?

- 스레드 데이터 구조
  - 스레드 식별, 자원 사용량 추정
- 스레드 생성 및 관리 매커니즘
- 스레드가 다음 작업을 수행하는 매커니즘
  - 동시에 서로 입력이나 결과 덮어쓰지 않도록 하기
  - 하나의 스레드가 결과를 기다릴 수 있도록 하기

#### 동시성 제어(Concurrency Control) vs 조정 (Coordination )

- 상호 배제 (mutual Exclusion)
  - 버스 줄 기다리는 것 처럼, 한번에 하나의 스레드만 허용되는 매커니즘
  - mutex 사용
  - 여러 프로세스나 스레드가 공유자원(데이터, 파일...)에 동시 사용하지 못하도록 막는 원칙

### 스레드 & 스레드 제작 예시

- 스레드 타입
  - 스레드 ID, PC, SP, 레지스터, 스택, 속성
  - 스레드 생성에 대해 FORK 제안 (proc, args)

```c
Thread thread1;
Shared_list list;
thread1 = fork(safe_insert,4);
safe_insert(6);
join(thread1); // Optional (메인 스레드 실행을 대기)
```

- 해당 결과는 4->6->nil / 6->4->nil 둘 다 가능하다.

#### 멀티 스레드 환경에서 포인터 주의점

```c
create new list element e
set e.value = X
read list and list.p_next
set e.pointer = list p_next
set list.p_next = e
```

- 동시성 문제의 시나리오를 계획해보자

1. 스레드 A와 B가 동시에 코드를 실행한다.
2. A가 'list.p_next'를 읽음 -> 'e'의 pointer를 이 값으로 설정
3. B가 거의 동시에 읽음 -> 또 다른 'e'의 pointer를 이 값으로 설정
4. 스레드 A가 'list.p_next'를 변경 -> 스레드 A가 'list.p_next'를 자신 새 요소 'e'로 설정한다.
5. 스레드 B가 'list.p_next'를 변경 -> 스레드 A가 'list.p_next'를 자신 새 요소 'e'로 설정한다.

#### mutex

위의 동시성 문제의 시나리오 떄문에 mutex 가 계획됐고 사용된다.

```c
mutex.lock(); // 동기화 시작
create new list element e
set e.value = X
read list and list.p_next
set e.pointer = list p_next
set list.p_next = e
mutex.unlock(); // 동기화 끝

```

---

Pintos code 살펴보기

- threads/init.c

  - 커널 초기화.
  - 최소한 main()을 살펴보고, 무엇이 초기화 되는지 확인해야한다.
  - 자신만의 초기화 코드를 추가할 수 있다.

- threads/thread.c

  - 대부분의 작업이 여기서 이뤄진다.
  - 기본적인 스레드를 지원하고, thread.h는 네 개의 프로젝트 모두 수정할 가능성이 높은 구조체 스레드를 정의한다. ( 다 수정해야 할 듯 )

- threads/synch.c

  - 세마포어, 잠금, 조건 변수, 최적화 배리어.
  - 네 프로젝트 모두에서 동기화를 위해 이들을 사용해야한다.

- devices/timer.c

  - 기본적으로 초당 100회 틱 하는 시스템 타이머, 여기 수정 해야 한다.

- 동기화

  - 문제를 해결하는데 인터럽트가 꺼진 동안에는 쉽게 해결 가능하지만 / 세마포어, 잠금, 조건 변수 등을 사용해 해결해야한다.
    (threads/synch.c의 주석 살펴보기)

  !! 커널 스레드와 인터럽트 핸덜러 간 공유되는 데이터를 조정할 때는 인터럽트 비활성화가 도움될 수 있다.

인터럽트 핸들러에서 약간의 스레드 상태만 엑세스하면 된다.
타이머 인터럽트는 몇 가지 전역 및 스레드 별 변수에 액세스해야한다.
커널 스레드에서 이러한 변수에 액세스 하는 경우, 타이머 인터럽트가 간섭하지 못하도록 인터럽트를 비활성화 해야한다.

인터럽트 해제시, 최소한의 코드만 해제하도록 주의할 것

---

키워드 정리

#### 프로세스, 스레드

- 프로세스
  - 어떤 작업을 위해 실행할 수 있는 파일
  - 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
  - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스 (독립적 개체)
  - 최소 1개의 스레드를 보유하고 있다.

```c
	/*
  threads/threads.c
  void thread_init (void)
  */
	initial_thread = running_thread ();
	init_thread (initial_thread, "main", PRI_DEFAULT);
	initial_thread->status = THREAD_RUNNING;
	initial_thread->tid = allocate_tid ();
```

- 별도의 주소 공간에서 진행하기 때문에, 통신을 위해선 IPC를 사용한다.

* 스레드
  - 프로세스 내에서 실행되는 여러 흐름의 단위
  - 프로세스의 특정한 수행 경로
  - stack만 따로 할당 받고, code,data,heap영역은 공유한다.

#### 컨텍스트 스위칭

- CPU에서 여러 프로세스를 돌아가면서 작업을 처리한다.

- 동작 중인 프로세스가 대기하면서 프로세스의 상태(Context)를 보관하고,
  대기하고 있던 다음 순서의 프로세스가 동작하며 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다.

- 멀티 프로세스의 단점에서 해당 부분이 중요하다.
  - 컨텍스트 스위칭 과정에서 캐쉬 메모리 초기화 등, 무거운 작업이 진행되고
    시간이 많이 소모되는 등 오버헤드가 발생한다.
  - 만약 콘텍스트 스위칭이 발생하면, 멀티 프로세스는 공유되는게 없어 '전부 다' 리셋 시키고 다시 받기 때문에 비효율적이다.

#### CPU 스케쥴링 알고리즘

- 선입 선처리 (first-come first served, fcfs)

  - CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다.
  - FIFO Queue로 쉽게 관리 가능하다.
  - 나머지 프로세스는 실행되지도, 자원을 소모하지도 않는다. '논다'

- 최단 작업 우선 (shortest job first, sjf)

  - 각 프로세스의 next CPU burst 길이를 고려한 알고리즘이다.
  - 가장 작은 next CPU burst를 가진 프로세스에 CPU를 할당한다.
  - 만약 같은 next CPU burst일 시, fcfs 처리를 적용한다.

- 라운드 로빈 (round robin, RR)

  - 시간 할당량(time quantum), 타임슬라이스(time slice)라고 하는 작은 단위의 시간을 정의한다.
  - CPU 스케쥴러는 준비 큐를 돌며 한 프로세스에 한 번의 시간 할당량 동안 CPU를 할당한다.
  - fcfs에서의 단점을 해결하고자 만들어진 알고리즘
  - 각 프로세스마다 (x)ms 만큼 쓰도록 해! 라고 지시하는것

- 우선순위 (priority)!!!

  - cpu는 우선순위가 가장 높은 프로세스에 할당된다.
  - 우선순위가 같은 프로세스들은 fcfs 순서로 스케쥴된다.

- 다단계 큐 (multilevel queue scheduling, mlfqs)
  - 우선순위마다 별도의 Queue를 가진다.
  - 우선순위가 가장 높은 큐에서 프로세스를 스케쥴한다.
  - 해당 알고리즘은 단일 프로세스가 아닌 '전체 프로세스의 효율성'을 위한 알고리즘

```c
+------------------+      +------------------+      +------------------+
|   시스템 큐      |      |   인터랙티브 큐   |      |   백그라운드 큐   |
| (우선순위: 높음) | ---> | (우선순위: 중간)  | ---> | (우선순위: 낮음)  |
|   RR 스케줄링    |      |   SJF 스케줄링    |      |   FCFS 스케줄링   |
+------------------+      +------------------+      +------------------+
```

#### 상호 배제 정책, 세마포어 vs 뮤텍스

- 왜 동시 접근하면 문제인가?

  - 공유된 자원에 여러 프로세스 혹은 스레드가 동시 접근하면 문제가 발생한다.

- 세마포어

  - 유지할 수 있는 값의 범위에 따라 이진 세마포어, 카운팅 세마포어로 구분된다.
  - 공유 자원에 세마포어의 수 만큼 프로세스(또는 스레드)가 접근 가능
  - 세마포어는 큐에 프로세스가 여러 개 있을 때 강성 vs 약성 세마포어에 따라 어떤 프로세스를 깨울지 결정된다.
  - 큐에 FIFO로 깨운다면 강성 세마포어, 아니면 약성 세마포어

- 뮤텍스
  - 프로세스 또는 스레드가 임계영역에 들어갈 때 lock을 걸어 다른 프로세스가 접근하지 못하도록 한다.

#### 데드락

- Lock이란?

  - 위의 뮤텍스에서 나온 개념으로서, 접근을 제한하는 기능이다.

- Lock Overhead

  - 락을 하기 위해 추가적인 자원이 소모된다.
    생성 및 소멸, 획득 반환에서 추가적 자원이 많이 발생함
  - 락 자체를 사용하는데 비용이 커진다

- Deadlock
  - 다익스트라가 만든 식사하는 철학자 문제가 대표적

```c
철학자1이 쪼금 고생하지만, 이해해달라

            철학자1
    /                     \
젓가락5                   젓가락1
  |                         |
철학자5                   철학자2
  |                         |
젓가락4                   젓가락2
    \                       /
    철학자4 ㅡ 젓가락3 ㅡ 철학자 3

```

- 문제 조건 - 철학자는 양 옆으로 있는 젓가락을 동시에 집어야 식사 가능하다.
- 문제 발생 요인 - 서로 원하는 자원이 상대방에게 할당되어 있어 다수의 프로세스는 무한정 wait 상태에 빠지게 된다.

  - 상호 배제
  - 점유 대기
  - 비선점
  - 순환 대기 의 4가지 조건이 만족해야 데드락이 발생한다.

- 은행원 알고리즘을 제안하긴 했음 100원이 있으면 a,b,c

예방 / 회피 / 무시 등의 방법이 있다.

#### 레이스 컨디션 (위의 동시성 문제 시나리오)

#### 인터럽트

> CPU가 프로그램을 실행할 때, 입출력 하드웨어 등 장치나 예외상황이 발생 해
> 처리가 필요한 경우, 마이크로프로세서에게 처리할 수 있도록 하는 것을 말함

- 하드웨어 인터럽트

* CPU가 아닌 하드웨어 장치가 CPU에 어떤 사실을 알려주거나 서비스 요청할 경우 발생

- 소프트웨어 인터럽트

* 소프트웨어가 발생시키는 인터럽트. 소프트웨어 스스로 인터럽트를 세팅

---

timer.c

```c

void
timer_sleep (int64_t ticks) {
	int64_t start = timer_ticks ();

	ASSERT (intr_get_level () == INTR_ON);
	while (timer_elapsed (start) < ticks)
		thread_yield ();
}

void
thread_yield (void) {
	struct thread *curr = thread_current ();
	enum intr_level old_level;

	ASSERT (!intr_context ());

	old_level = intr_disable ();
	if (curr != idle_thread)
		list_push_back (&ready_list, &curr->elem);
	do_schedule (THREAD_READY);
	intr_set_level (old_level);
}

```

- timer_sleep

  - 현재, 실행되고 있는 스레드를 ticks 만큼 재우는 함수다.
  - elapsed는, 인수로 받은 tick, 현재 tick 차이 반환 함수
  - 즉, start로 부터 지난 tick이 ticks보다 작으면, 양보 함수 실행한다.
    - !! while이 반복 실행되면서 양보가 계속 발생한다. <- 이걸 고쳐야 할 듯

- thread_yield

  - old레벨은 인터럽트를 비활성하고, 이전 상태를 반환한다
  - 만약 최근 스레드가 빈 스레드가 아니라면 리스트의 끝에 elem를 삽입한다.
  - 준비된 스레드로 전환한다.
  - 기존 인터럽트 비활성상태를 인터럽트 레벨로 지정

- purpose
  - ready_list -> sleep_list?
    thread_sleep() 함수를 호출하면 해당 Thread를 sleep_list에 넣고, 이 Thread를 깨워야할 때 thread_awake() 함수를 호출한다.
    깨어난 Thread를 다시 ready_list로 옮기는 식으로 구현하면 sleep_list에 있는 Thread는 CPU를 점유하지 않고 자신이 깨어나야 할 때까지 기다릴 수 있을 것이다
