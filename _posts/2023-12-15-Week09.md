---
title: 정글 9주차
author: cotes
date: 2023-12-15 14:30:00 +0800
categories: [크래프톤 정글]
tags: [PintOS]
pin: true
math: true
mermaid: true
---

# 2023.12.14 TIL

## Instruction 정리 & 구현

---

### Introduction

`include/vm/vm.h`, `vm/vm.c`

- 기본적인 Virtual Memory 인터페이스 제공

- 헤더 파일에서 가상 시스템 메모리가 지원해야 할 다양한 VM\_ 유형에 대한 정의와 설명을 볼 수 있다.

> > VM_PAGE_CACHE는 현재 무시해도 좋음

`include/vm/uninit.h`, `vm/uninit.c`

- 초기화되지 않은(uninit) 상태의 페이지에 대한 작업을 제공한다.

- 현재 설계에서는 모든 페이지가 초기화 되지 않은 상태에서 설정된 후, 익명 페이지 또는 파일 백업 페이지로 변환한다.

`include/vm/anon.h`, `vm/anon.c`

- 익명 페이지(vm_type =)에 대한 작업 지원

`include/vm/file.h`, `vm/file.c`

- 파일 지원 페이지(vm_type =)에 대한 작업 지원

`include/devices/block.h`, `devices/block.c`

- 블록 장치에 대한 섹터 기반 읽기 및 쓰기 액세스를 제공합니다.

- 이 인터페이스를 사용하여 스왑 파티션에 블록 장치로 액세스할 수 있습니다.

#### 가상 주소 구성

- 가상 페이지는 4096 바이트로 이루어진 가상 메모리의 연속이다.

- 페이지는 정렬된 상태에서 시작해야하며, 마지막 12 비트는 페이지의 오프셋이다.
  - 이후 Frame과 매핑된다.

```bash
63          48 47            39 38            30 29            21 20         12 11         0
+-------------+----------------+----------------+----------------+-------------+------------+
| Sign Extend |    Page-Map    | Page-Directory | Page-directory |  Page-Table |    Page    |
|             | Level-4 Offset |    Pointer     |     Offset     |   Offset    |   Offset   |
+-------------+----------------+----------------+----------------+-------------+------------+
              |                |                |                |             |            |
              +------- 9 ------+------- 9 ------+------- 9 ------+----- 9 -----+---- 12 ----+
                                          Virtual Address
```

#### Frame (물리 주소)

- 가상 주소의 Page-Talbe Offset과 매핑되는 주소이다.

- pintos는 물리 주소와 가상 주소 사이를 번역하는 기능을 제공한다.

```bash
                          12 11         0
    +-----------------------+-----------+
    |      Frame Number     |   Offset  |
    +-----------------------+-----------+
              Physical Address
```

#### page table

- CPU가 가상 주소를 물리 주소로, 즉 페이지에서 프레임으로 변환하는데 사용되는 데이터 구조이다.
  `threads/mmu.c`에 페이지 타이블 관리 코드를 제공한다.

```bash
                        +----------+
         .--------------->|Page Table|-----------.
        /                 +----------+            |
        |   12 11 0                               V  12 11 0
    +---------+----+                         +---------+----+
    | Page Nr | Ofs|                         |Frame Nr | Ofs|
    +---------+----+                         +---------+----+
     Virt Addr   |                            Phys Addr    ^
                  \_______________________________________/
```

#### 리소스 관리 개요

1. 추가 페이지 테이블

- 페이지 테이블을 보완하여 페이지 장애 처리를 활성화합니다.

- 커널은 프로세스가 종료되면 추가 페이지 테이블을 참조하여 어떤 리소스를 확보할지 결정합니다.

- 세그먼트 or 페이징 측면에서 접근하는 것을 권장한다.

> > 페이지 폴트 처리

[1] 페이지 폴트 발생 위치를 Supplemental Page Table에서 찾고, 유효한 메모리 참조 시 해당 페이지의 데이터를 확인합니다.

[2] 페이지를 저장할 프레임을 얻어야 하며, 데이터가 이미 프레임에 있는 경우 해당 프레임을 찾아야 합니다.

[3] 데이터를 파일 시스템이나 스왑에서 읽거나 0으로 초기화하여 프레임에 가져옵니다.

[4] 폴트가 발생한 가상 주소의 페이지 테이블 항목을 해당하는 물리 페이지로 지정합니다.

2. 프레임

- 물리적 프레임의 퇴거 정책을 효율적으로 구현할 수 있습니다.

- 사용자 페이지에 사용되는 프레임은 "user pool"에서 palloc_get_page(PAL_USER)를 호출하여 얻어져야 합니다. PAL_USER를 사용하여 "kernel pool"에서 할당하는 것을 피해야 하며, 이로 인해 테스트 케이스가 예상치 못하게 실패할 수 있습니다. palloc.c를 수정하는 경우, 두 풀 간의 구별을 유지해야 합니다.

- 프레임 테이블에서 가장 중요한 작업은 사용되지 않은 프레임을 얻는 것입니다. 프레임이 비어있을 때는 간단하지만, 비어 있지 않은 경우 페이지를 프레임에서 교체함으로써 빈 프레임을 만들어야 합니다.

- 만약 스왑 슬롯을 할당하지 않고 프레임을 교체할 수 있는 프레임이 없다면, 그리고 스왑이 가득 차 있다면, 커널을 패닉 상태로 만듭니다.

> > 프레임 교체 과정

[1] 페이지 교체 알고리즘을 사용하여 교체할 프레임을 선택합니다.
아래에서 설명하는 페이지 테이블의 "accessed" 및 "dirty" 비트가 유용합니다.

[2] 프레임을 참조하는 모든 페이지 테이블에서 해당 프레임에 대한 참조를 제거합니다.
공유를 구현하지 않은 경우, 한 번에 하나의 페이지만이 프레임을 참조해야 합니다.

[3] 필요한 경우 페이지를 파일 시스템이나 스왑에 기록합니다.
그런 다음, 교체된 프레임은 다른 페이지를 저장하는 데 사용될 수 있습니다.

3. 스왑테이블

- 스왑 테이블은 사용 중인 스왑 슬롯과 빈 스왑 슬롯을 추적합니다.
- 페이지를 프레임에서 스왑 파티션으로 이동시키기 위해 사용되지 않은 스왑 슬롯을 선택할 수 있어야 합니다.
- 또한, 해당 페이지의 내용이 다시 읽히거나 페이지를 스왑한 프로세스가 종료될 때 스왑 슬롯을 해제할 수 있어야 합니다.

> > 주의 사항

스왑 슬롯은 필요시에만 할당되어야 하며, eviction에 실제로 필요할 때에만 할당되어야 합니다. 실행 파일에서 데이터 페이지를 읽고 즉시 스왑에 쓰는 것은 레이지(lazy)하지 않습니다. 스왑 슬롯은 특정 페이지를 저장하기 위해 예약되어서는 안 됩니다.

#### 메모리 매핑된 파일 관리

파일 시스템은 주로 읽기 및 쓰기 시스템 호출을 사용하여 액세스됩니다. 보조적으로 "매핑"을 통해 파일을 가상 페이지에 매핑하는 방법도 있습니다. mmap 시스템 호출을 사용하여 파일을 가상 페이지로 매핑할 수 있습니다. 프로그램은 그 후에 파일 데이터에 직접 메모리 명령을 사용할 수 있습니다.

만약 파일 'foo'가 0x1000 바이트 (4 KB 또는 한 페이지) 길이라면, 'foo'가 주소 0x5000에서 메모리에 매핑되면, 주소 0x5000부터 0x5fff까지의 메모리 액세스는 'foo'의 해당 바이트에 액세스하게 됩니다.

mmap을 사용하여 파일을 콘솔에 출력하는 프로그램은 주어진 코드입니다. 이는 명령 줄에서 지정된 파일을 열고, 주소 0x10000000에 매핑하며, 매핑된 데이터를 콘솔(fd 1)에 작성한 후 파일을 언매핑합니다.

제출물은 메모리 매핑된 파일에서 사용 중인 메모리를 추적할 수 있어야 합니다. 이는 매핑된 영역에서 페이지 폴트를 적절하게 처리하고, 매핑된 파일이 프로세스 내의 다른 세그먼트와 겹치지 않도록 보장하기 위해 필요합니다.

---

### Memory Management

#### struct page

```c
// include/vm/vm.h

struct page {
  const struct page_operations *operations;
  void *va;              /* Address in terms of user space */
  struct frame *frame;   /* Back reference for frame */

  union {
    struct uninit_page uninit;
    struct anon_page anon;
    struct file_page file;
#ifdef EFILESYS
    struct page_cache page_cache;
#endif
  };
};

```

- 페이지 동작, 가상 주소, 물리적 프레임을 가지며 union 필드를 추가로 가진다.
  - 메모리 영역에 다양한 유형의 데이터를 저장할 수 있게 해주는 특수 데이터 유형
  - 여러 멤버가 있지만 하나의 멤버만 값이 들어갈 수 있다.

#### page 동작

페이지는 VM_UNINIT, VM_ANON 또는 VM_FILE이 될 수 있다.
각 페이지에는 필요한 단계와 작업이 다르며, C언어에서 이를 실현하기 위해 함수 포인터를 사용한다.

```c
struct page_operations {
  bool (*swap_in) (struct page *, void *);
  bool (*swap_out) (struct page *);
  void (*destroy) (struct page *);
  enum vm_type type;
};
```

- 이는 파일 지원 페이지에 대한 함수 포인터 테이블입니다.
  .destroy 필드는 file_backed_destroy 함수를 가리키며, 이는 동일한 파일에서 정의된 페이지를 파괴하는 함수입니다.

destroy(page) 매크로에 대한 설명을 보면 실제로 destroy 함수를 호출하는 것은 (page)->operations->destroy (page)이며, 이는 페이지 구조체에서 검색된 destroy 함수를 호출합니다. 페이지가 VM_FILE 페이지인 경우, .destroy 필드는 file_backed_destory를 가리키게 됩니다. 결과적으로 파일 지원 페이지의 파괴 루틴이 수행됩니다.

#### 보조 페이지 테이블 구현

우리는 pm14를 통해 페이지 테이블을 관리하지만, 해당 페이지 테이블 이상으로 관리가 필요한 상황이다.
그러므로, vm.c에서 supplemental page table 관리 함수를 구현한다.

[1] `void supplemental_page_table_init (struct supplemental_page_table *spt);`

보조 페이지 테이블을 초기화합니다.
보조 페이지 테이블에 사용할 데이터 구조를 선택할 수 있습니다.
이 함수는 새로운 프로세스가 시작될 때(initd in userprog/process.c) 및 프로세스가 포크될 때(\_\_do_fork in userprog/process.c) 호출됩니다.

[2] `struct page *spt_find_page (struct supplemental_page_table *spt, void *va);`

주어진 보조 페이지 테이블에서 va에 해당하는 struct page를 찾습니다. 실패하면 NULL을 반환합니다.

[3] `bool spt_insert_page (struct supplemental_page_table *spt, struct page *page);`

주어진 보조 페이지 테이블에 struct page를 삽입합니다. 이 함수는 주어진 보조 페이지 테이블에 가상 주소가 이미 존재하지 않는지 확인해야 합니다.

#### 프레임 관리

include/vm/vm.h에는 물리 메모리를 나타내는 struct frame은 아래와 같다.

```c
/* 물리적 "프레임"의 표현 */
struct frame {
  void *kva;
  struct page *page;
};
```

kva는 커널 가상 주소이고 page는 페이지 구조체입니다.
프레임 관리 인터페이스를 구현하는 동안 더 많은 멤버를 추가할 수 있습니다.

`static struct frame *vm_get_frame (void);`
사용자 풀에서 새로운 물리 페이지를 얻습니다. 사용자 풀에서 페이지를 성공적으로 얻으면 프레임을 할당하고 그 멤버를 초기화한 후 반환합니다. vm_get_frame를 구현한 후에는 모든 사용자 공간 페이지(PALLOC_USER)를 이 함수를 통해 할당해야 합니다. 지금은 페이지 할당 실패 시 스왑 아웃을 처리할 필요가 없습니다. 지금은 그냥 PANIC ("todo")로 마크해두세요.

`bool vm_do_claim_page (struct page *page);`

페이지를 할당, 즉 물리 프레임을 할당합니다. 먼저 vm_get_frame을 호출하여 프레임을 얻어야 합니다(템플릿에서 이미 완료). 그런 다음 MMU를 설정해야 합니다. 다시 말해, 가상 주소에서 물리 주소로의 매핑을 페이지 테이블에 추가해야 합니다. 반환 값은 작업이 성공했는지 여부를 나타내어야 합니다.

`bool vm_claim_page (void *va);`

페이지를 할당하여 va를 할당합니다. 먼저 페이지를 얻은 다음 해당 페이지와 함께 vm_do_claim_page를 호출해야 합니다.

---

### 구현
