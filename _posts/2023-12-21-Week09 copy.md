---
title: 정글 9주차
author: cotes
date: 2023-12-21 14:30:00 +0800
categories: [크래프톤 정글]
tags: [PintOS]
pin: true
math: true
mermaid: true
---

# 2023.12.21 TIL

#### 전 날 정리

기존 코드

```c
static void vm_stack_growth(void *addr UNUSED) {
  void *newstack_addr = pg_round_down(addr);

  if (spt_find_page(&thread_current()->spt, addr))
	return;

	uintptr_t stack_bottom = pg_round_down(addr);
	vm_alloc_page(VM_ANON, stack_bottom, true);
}
```

```c
static void
vm_stack_growth (void *addr UNUSED) {
	if (vm_alloc_page(VM_ANON|VM_MARKER_0, addr, 1)) {

		//vm_claim_page(addr);
		thread_current()->stack_bottom -= PGSIZE;
	}
}
```

1. 상우님 코드 (페이지 테이블을 확인한 뒤, 스택에 페이지 추가)

새로운 스택의 주소를 계산하고, 이 주소가 이미 페이지 테이블에 존재하는지 확인한다.
이미 존재한다면 함수는 반환되며, 아니면 새 페이지를 할당하고 스택에 추가한다.

2. 내 코드 (먼저 페이지를 할당하고 스택에 추가)

페이지를 먼저 할당하고 할당된 페이지를 스택에 추가한다.
현재 스래드 스택 하단을 갱신한다.

이를 통해 스택이 성장하는 과정을 처리한다. VM_ANON과 MAKER_0를 사용함으로서 페이지 유형과 상태를 명시적으로 표시

```c
/* Return true on success */
bool vm_try_handle_fault(struct intr_frame *f UNUSED, void *addr UNUSED,
                         bool user UNUSED, bool write UNUSED,
                         bool not_present UNUSED) {
    struct supplemental_page_table *spt UNUSED = &thread_current()->spt;
    struct page *page = NULL;
	// /* TODO: Validate the fault */
	if (is_kernel_vaddr(addr) || addr == NULL) {
		return false;
	}

	// /* TODO: Your code goes here */
  uintptr_t stack_limit = USER_STACK - (1 << 20);
	uintptr_t rsp = user ? f->rsp : thread_current()->user_rsp;
	if (addr >= rsp - 8 && addr <= USER_STACK && addr >= stack_limit) {
		vm_stack_growth(addr);
    }

	if ((page = spt_find_page(spt, addr)) == NULL) {
		return false;
	}

    page = spt_find_page(spt, addr);
    return vm_do_claim_page(page);
}
```

```c
bool
vm_try_handle_fault (struct intr_frame *f , void *addr ,bool user , bool write , bool not_present) {
	struct supplemental_page_table *spt UNUSED = &thread_current ()->spt;
	struct page *page = NULL;

	if(is_kernel_vaddr(addr) || addr == NULL){
		return false;
	}

	if(not_present){
		// thread 구조체 내의 rsp_stack을 설정
		struct thread* cur = thread_current();
		void *rsp_stack = !user ? cur->rsp_stack : f->rsp;

		if (rsp_stack-8 <= addr  && USER_STACK - 0x100000 <= addr && addr <= USER_STACK){
				vm_stack_growth(pg_round_down(addr));
		}
		page = spt_find_page(spt,addr);
		if(page == NULL){
			return false;
		}
		if(write && !page->writable){
			return false;
		}
		if (!vm_do_claim_page(page)){
			return false;
		}
		return true;
	}
	return false;
}
```

1. 상우님 코드
   rsp의 값을 thread_current() -> user_rsp 또는 f->rsp로 설정하고
   addr가 rsp-8과 USER_STACK 사이에 있으면 vm_stack_growth(addr)를 호출한다.

vm_do_claim_page가 실패하면 함수는 직접 값을 반환한다.

2. 내 코드

rsp_stack 값을 cur->rsp_stack 또는 f->rsp로 설정하고,
addr가 rsp-8과 USER_STACK 사이에 있으면 vm_stack_growth(addr)를 호출한다.

not_present 플래그를 확인하고, 페이지가 쓰기 가능한지 확인한다.
둘 중하나라도 만족하지 않으면 실패 반환

vm_do_claim_page가 실패하면 함수는 실패(false)를 반환한다.

---

## mmap 추가 정리

- 왜 매핑을 해야하는가?

* 파일과 메모리를 매핑 시, 파일을 메모리처럼 접근할 수 있게 되어서 파일 입출력의 효율성을 향상할 수 있다.
  이렇게 파일과 매핑된 메모리 영역은 가상 주소 공간에서 접근 가능하며, 해당 영역에 대한 읽기/쓰기 작업이 가능해진다.
  쓰기 작업으로 인해 파일의 내용이 변경되면 매핑이 해제(unmap) 될 때 디스크의 실제 파일에 해당 변경 사항이 반영된다.

#### mmap 함수

- 여러 페이지에 매핑되는 파일 처리
  읽어올 길이인 length가 한 페이지 사이즈를 넘어갈 경우에는 한 파일의 내용이 여러 페이지에 걸쳐 매핑된다.
  매핑을 진행할 때는 간단하게 (addr + PGSIZE)에 위치하는 다음 페이지에 이어서 매핑하면 되지만,
  해제 시에는 몇 번째 페이지까지 해제해야 하는지 알아야한다.

즉, 총 몇번째 페이지를 사용해 매핑이 이뤄졌는지 page 구조체에 저장해둔다.
